Expandicon
==========

Expandicon is a console implementation that can be used in Unity3D projects in order to change values and perform specific operations on GameObjects without interacting the Unity3D editor. 

Expandicon stands for <b>Expandable Console</b> which identifes its main feature: expandability.

Project Expandicon is currently under development.

Current features:

- Variable and GameObject registration to manage them inside the console
- Custom command registration
- get/set/reset the value of a variable
- get/set position of a GameObject
- time command to get UnityEngine.Time.time
- sendrate command to set Network.sendRate
- activate/deactive a GameObject
- Command completion
- Console panel with command history


Getting Started
===============

Core of the console does not require a GUI to work. Therefore, in order to perform operations such as running a commmand or autocompleting an input, you can directly use its related methods by passing strings.

Console is a singleton class which utilizes from publish/subscribe design pattern to notify its subscribers about the output messages generated by the console or the command. By using the related interface, you can use the messages to print on your own console GUI or a console logger.


Console Panel
--------

![Preview ConsolePanel](https://raw.github.com/asekerefe/Expandicon/master/screenshot/ConsolePanel.png)

Expandicon comes with a console panel prefab which handles IO operations and prints output messages from Console. 

To use it in your projects: 
- import the package. 
- create a layer named GUI. 
- set the culling mask of your cameras to ignore GUI layer

Registration
------------

In order to start using Expandicon to manage your variables or GameObjects runtime, you should register them to the console. 

Variables
--------

To register a variable, you should pass its object and the target variable's name as string with an alias:
<code>Console.getSingleton().registerVariable("pID", obj, "playerID");</code>

After registering the variable, you will able to run related commands on your variables.

For instance, to change the value of PlayerID variable to 10, you should type <b>set pID 10</b>.

![Preview ConsolePanel](https://raw.github.com/asekerefe/Expandicon/master/screenshot/PlayerID.png)


GameObjects
--------

Currently, target GameObjects are registered the same with Variables. However, you can define your auto registration script to add them on desired GameObjects.

To register a GameObject to the console, you should send an alias and object's itself.
 
<code>Console.getSingleton().registerGameObject("box", gameObject);</code>

Now, defined commands can be run on box game object. For instance, you can type <b>setposition box 0 10 0</b> to set its position to (0,10,0)


Commands
--------

Commands are tiny methods which work on the given parameters (if necessary). The first word of the console input must always be the command's name. 

There are 3 types of commands:
- Variable: This command type requires a valid variable name to run. Since the console checks the type of the passed parameter before running the command, the first parameter of the command should be a Variable alias.

![Preview Variable](https://raw.github.com/asekerefe/Expandicon/master/screenshot/VariableCommand.png)

- GameObject: This type of a command work on a GameObject. In order to run it, second parameter should be a valid GameObject alias.

![Preview GameObject](https://raw.github.com/asekerefe/Expandicon/master/screenshot/GameObjectCommand.png)

- Generic: Unlike the first two command types, with a Generic Command, console does not perform type checking before running it. In other words, this command type is used for making system commands which do not require specific type of parameters.

![Preview Generic](https://raw.github.com/asekerefe/Expandicon/master/screenshot/GenericCommand.png)


Making Your Own Commands
========================

You can define your own custom commands by extending <b>Command</b> abstract class. 

<i>getParameterType</i> method must be implemented to tell Console what kind of a parameter the command needs. 

In addition, it contains three overloaded virtual <i>runCommand</i> methods for three types of commands. You should override the relevant method according to the type of command you are implementing.

Destroy Command: Making of
---------------

Let's implement a command that destroy's the given GameObject.

First things first; we create a class that extends Command. It's constructor should be passing the command's name to the base (to be used in the console).

Then, we implement <i>getParameterType</i> to identify its type as GameObject;

Finally, because this command will be running on a GameObject, we should override the <i>runCommand</i> method which takes a GameObject. This method will be called by the console after validating that given parameter is really a GameObject. Also, it returns a feedback message to tell the user whether the operation was successful or not.

At the end, class should look like this and the command is ready to operate;


    public class DestroyCommand : Command
    {
        public DestroyCommand() : base("destroy") { }

        public override ParameterType getParameterType()
        {
            return ParameterType.GAMEOBJECT;
        }

        public override string runCommand(GameObject gameObject, string[] parameters)
        {
            GameObject.Destroy(gameObject);
            return "GameObject has been destroyed";
        }
    }


Like Variables and GameObjects, a custom command should be registered to the core.

<code>Console.getSingleton().registerCommand(new DestroyCommand());</code>

Now, this command can be run like this:

<b>destroy box</b>

And the result would be:

![Preview ConsolePanel](https://raw.github.com/asekerefe/Expandicon/master/screenshot/DestroyCommandOutput.png)


Note: The parameter array comes from the console could be filled or empty (depending on the console input). Although I've created a command for each type of operation (for example, GetPosition and SetPosition) for simplification,  your can process those parameters to overload your command. 

Let's say you want to overload the destroy command so that it could perform two different destroy operations: GameObject.Destroy and GameObject.DestroyImmediate. You would pass the input as <b>destroy box i</b>. In this case, the first element of the parameter array will be <b>i</b>. By checking the parameter array, you can change the behavior of <i>destroy</i>.
